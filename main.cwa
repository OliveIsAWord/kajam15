include "microw8-api.cwa"

global mut x = 160.0;
global mut y = 120.0;
global mut prevTime = 0.0;
const SPEED = 180.0;
const DASH_DISTANCE = 60.0;
const PLAYER_SIZE = 8.0;
const MOVE_ITERS = 10;

// GHOST_DATA: [0x4000; (i16, i16)]
// ghostHead indexes where the next ghost should be written
// ghostTail indexes the oldest ghost
// GHOST_DATA[ghostTail..ghostHead] is all ghosts from oldest to youngest
//   - this slice will always be contiguous;  all data is copied to
//     the beginning of GHOST_DATA when ghostHead would exceed 0x4000
//   - the length of this slice will be smaller than ghostLen if
//     the game has recently started or ghostLen was recently increased.
// ghostHead - ghostTail <= ghostLen

const GHOST_FPS = 70.0;
const GHOST_DATA = 0x30000;
const GHOST_CAP = (0x40000 - GHOST_DATA) / 4;
global mut prevTimeGhost = 0.0;
global mut ghostLen = 210;
global mut ghostHead = 0;
global mut ghostTail = 0;

// Static bodies are stored as a null terminated array of
// { x: u8, y: u8, r: u8, _: u8 }.
const STATIC_DATA = 0x28000;

export fn start() {
    0!STATIC_DATA = 0x507820;
    4!STATIC_DATA = 0xf07820;
    8!STATIC_DATA = 0;
}

fn clearGhosts() {
    ghostTail = ghostHead;
}

fn pushGhost() {
    if ghostHead >= GHOST_CAP {
        let i: i32;
        loop GhostCopy {
            if i + ghostTail < ghostHead {
                (i*4)!GHOST_DATA = ((i+ghostTail)*4)!GHOST_DATA;
                i += 1;
                branch GhostCopy;
            }
        }
        ghostHead = i;
        ghostTail = 0;
    }
    (ghostHead*4)!GHOST_DATA = ((x as i32 << 16) | y as i32) ^ (1 << 30);
    ghostHead += 1;
    if ghostHead - ghostTail > ghostLen {
        ghostTail = ghostHead - ghostLen;
    }
}

// If circles C1 and C2 collide, returns 1 and assigns a new C1 in x and y
// so that it touches C2 exactly. Else, returns 0 and dx and dy are unspecified.
global mut circleCollide_x = 0.0;
global mut circleCollide_y = 0.0;
fn circleCollide(x1: f32, y1: f32, r1: f32, x2: f32, y2: f32, r2: f32) -> i32 {
    let gpX = x1 - x2;
    let gpY = y1 - y2;
    let mag = sqrt(gpX * gpX + gpY * gpY);
    let r = r1 + r2;
    circleCollide_x = x2 + r / mag * gpX;
    circleCollide_y = y2 + r / mag * gpY;
    mag < r
}

export fn upd() {
    cls(0);
    let dt = time() - prevTime;
    prevTime = time();
    let mx = if isButtonPressed(BUTTON_LEFT) {
        -1.0
    } else if isButtonPressed(BUTTON_RIGHT) {
        1.0
    } else {
        0.0
    };
    let my = if isButtonPressed(BUTTON_UP) {
        -1.0
    } else if isButtonPressed(BUTTON_DOWN) {
        1.0
    } else {
        0.0
    };
    let mag = sqrt(mx*mx + my*my);
    if mag != 0.0 {
        mx /= mag;
        my /= mag;
    }
    let nx = x;
    let ny = y;
    let isDash = isButtonTriggered(BUTTON_B);
    if isDash {
        nx += mx * DASH_DISTANCE;
        ny += my * DASH_DISTANCE;
        nx = clamp(nx, PLAYER_SIZE, 320.0 - PLAYER_SIZE);
        ny = clamp(ny, PLAYER_SIZE, 240.0 - PLAYER_SIZE);
    } else {
        let iters: i32;
        loop GhostCollideIter {
        let oldX = nx;
        let oldY = ny;
        nx += mx * SPEED * dt / MOVE_ITERS as f32;
        ny += my * SPEED * dt / MOVE_ITERS as f32;
        nx = clamp(nx, PLAYER_SIZE, 320.0 - PLAYER_SIZE);
        ny = clamp(ny, PLAYER_SIZE, 240.0 - PLAYER_SIZE);
        let i = ghostTail;
        let didCollide: i32;
        loop GhostCollide {
            if i < ghostHead {
                let data = (i*4)!GHOST_DATA;
                if !((data >> 31) ^ (data >> 30) & 1) {
                    let ix = (data >> 16) as f32;
                    let iy = sext16(data & 0xffff) as f32;
                    if circleCollide(nx, ny, PLAYER_SIZE, ix, iy, PLAYER_SIZE) {
                        didCollide = 1;
                        nx = circleCollide_x;
                        ny = circleCollide_y;
                    }
                }
                i += 1;
                branch GhostCollide;
            }
        }
        i = 0;
        loop StaticCollide {
            let staticX = (i*4 + 2)?STATIC_DATA;
            let staticY = (i*4 + 1)?STATIC_DATA;
            let staticR = (i*4)?STATIC_DATA;
            if staticX | staticY | staticR {
                if circleCollide(nx, ny, PLAYER_SIZE, staticX as f32, staticY as f32, staticR as f32) {
                    //didCollide = 1;
                    nx = circleCollide_x;
                    ny = circleCollide_y;
                }
                i += 1;
                branch StaticCollide;
            }
        }            
        if didCollide {
            didCollide = 0;
            loop GhostCollidePost {
                if i < ghostHead {
                    let data = (i*4)!GHOST_DATA;
                    if !((data >> 31) ^ (data >> 30) & 1) {
                        let ix = (data >> 16) as f32;
                        let iy = sext16(data & 0xffff) as f32;
                        if circleCollide(nx, ny, PLAYER_SIZE, ix, iy, PLAYER_SIZE) {
                            didCollide = 1;
                            nx = oldX;
                            ny = oldY;
                        } else {
                            i += 1;
                            branch GhostCollidePost;
                        }
                    } else {
                        i += 1;
                        branch GhostCollidePost;
                    }
                }
            }
        }
        branch_if !didCollide & ((iters := iters + 1) < MOVE_ITERS): GhostCollideIter;
        }
    }
    x = nx;
    y = ny;
    let i: i32;
    loop StaticDraw {
        let staticX = (i*4 + 2)?STATIC_DATA;
        let staticY = (i*4 + 1)?STATIC_DATA;
        let staticR = (i*4)?STATIC_DATA;
        if staticX | staticY | staticR {
            circle(staticX as f32, staticY as f32, staticR as f32, 0x14);
            i += 1;
            branch StaticDraw;
        }
    }
    i = ghostTail;
    let data: i32;
    loop GhostDraw {
        if i < ghostHead {
            data = (i*4)!GHOST_DATA;
            let isActive = !(((data >> 31) ^ (data >> 30)) & 1);
            data ^= !isActive << 30;
            let ix = (data >> 16) as f32;
            let iy = sext16(data & 0xffff) as f32;
            let dist = sqrt(pow(x - ix, 2.0) + pow(y - iy, 2.0));
            if !isActive & dist >= 2.0*PLAYER_SIZE {
                isActive = 1;
                (i*4)!GHOST_DATA = data;
            }
            let color = {
                let meow = (ghostHead - i) as f32 / (ghostHead - ghostTail) as f32 * -3.0;
                meow as i32 + (fmod(meow, 1.0) > randomf()) + 4
            };
            circle(ix, iy, PLAYER_SIZE, color);
            i += 1;
            branch GhostDraw;
        }
    }
    circle(floor(x), floor(y), PLAYER_SIZE, 0x0f);
    i = (GHOST_FPS * (time() - prevTimeGhost)) as i32;
    loop ghostsToAdd {
        if i {
            prevTimeGhost = time();
            pushGhost();
            i -= 1;
            branch ghostsToAdd;
        }
    }
}

fn sext16(v: i32) -> i32 {
    v + (v #>> 15) * 0xffff0000
}

fn clamp(v: f32, min: f32, max: f32) -> f32 {
    if v < min { min } else if v > max { max } else { v }
}

