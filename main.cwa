include "microw8-api.cwa"

global mut x = 160.0;
global mut y = 120.0;
global mut prevTime = 0.0;
const SPEED = 180.0;
const DASH_SPEED = 60.0;
const PLAYER_SIZE = 8.0;

// -------------------------
// |  |  |  |  |  |  |  |  |
// -------------------------
//    ^        ^            ^
//    |     ghost_index     |
//    |                  0x40000
// 0x40000 - ghost_len * 8
// where ghost_len = 7
//       ghost_index = 3

const GHOST_FPS = 60.0;
const GHOST_DATA = 0x40000;
global mut prevTimeGhost = 0.0;
global mut ghost_len = 120;
global mut ghost_index = 0;

export fn start() {
    clearGhosts();
}

fn clearGhosts() {
    let i = GHOST_DATA - 8 * ghost_len;
    loop ghostClear {
        i$0 = -10000.0;
        i$4 + -10000.0;
        branch_if (i := i + 8) < GHOST_DATA: ghostClear;
    }
}

fn pushGhost() {
    let ptr = GHOST_DATA - 8 * (ghost_len - ghost_index);
    printChar('\06');
    printInt(ptr);
    ptr$0 = x;
    ptr$4 = y;
    ghost_index = (ghost_index + 1) % ghost_len;
}

export fn upd() {
    cls(0);
    let dt = time() - prevTime;
    prevTime = time();
    let mx = if isButtonPressed(BUTTON_LEFT) {
        -1.0
    } else if isButtonPressed(BUTTON_RIGHT) {
        1.0
    } else {
        0.0
    };
    let my = if isButtonPressed(BUTTON_UP) {
        -1.0
    } else if isButtonPressed(BUTTON_DOWN) {
        1.0
    } else {
        0.0
    };
    let mag = sqrt(mx*mx + my*my);
    if mag != 0.0 {
        mx /= mag;
        my /= mag;
    }
    let nx = x;
    let ny = y;
    if isButtonTriggered(BUTTON_B) {
        nx += mx * DASH_SPEED;
        ny += my * DASH_SPEED;
    } else {
        nx += mx * SPEED * dt;
        ny += my * SPEED * dt;
    }
    nx = clamp(nx, PLAYER_SIZE, 320.0 - PLAYER_SIZE);
    ny = clamp(ny, PLAYER_SIZE, 240.0 - PLAYER_SIZE);
    let i = GHOST_DATA - 8 * ghost_len;
    loop ghostCollide {
        let dist = sqrt(pow(nx - i$0, 2.0) + pow(ny - i$4, 2.0));
        let lmao = sqrt(pow( x - i$0, 2.0) + pow( y - i$4, 2.0));
        if dist < 2.0 * PLAYER_SIZE & lmao > 2.0 * PLAYER_SIZE {
            nx = x;
            ny = y;
        } else {
            branch_if (i := i + 8) < GHOST_DATA: ghostCollide;
        }
    }
    x = nx;
    y = ny;
    let i = 0;
    loop ghosts {
        let ptr = GHOST_DATA - 8 * ghost_len + (ghost_index + i) % ghost_len * 8;
        let meow = i as f32 / ghost_len as f32 * 3.0;
        circle(ptr$0, ptr$4, PLAYER_SIZE, meow as i32 + (fmod(meow, 1.0) > randomf()) + 1);
        branch_if (i := i + 1) < ghost_len: ghosts;
    }
    circle(floor(x), floor(y), PLAYER_SIZE, 15);
    i = (GHOST_FPS * (time() - prevTimeGhost)) as i32;
    loop ghostsToAdd {
        if i {
            prevTimeGhost = time();
            pushGhost();
            i -= 1;
            branch ghostsToAdd;
        }
    }
}

fn clamp(v: f32, min: f32, max: f32) -> f32 {
    if v < min { min } else if v > max { max } else { v }
}

